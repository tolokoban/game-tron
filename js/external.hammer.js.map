{"version":3,"sources":["external.hammer.js"],"names":["require","module","exports","_","D","X","intl","arguments","all","window","document","exportName","undefined","VENDOR_PREFIXES","TEST_ELEMENT","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","deprecate","method","name","message","deprecationMessage","e","Error","stack","replace","log","console","warn","apply","assign","Object","target","TypeError","output","index","source","nextKey","extend","dest","src","merge","keys","inherit","child","base","properties","baseP","prototype","childP","create","constructor","_super","boundFn","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","sortUniqueArray","a","b","prefixed","property","camelProp","toUpperCase","prefix","prop","_uniqueId","uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","MOBILE_REGEX","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","Input","manager","callback","that","options","inputTarget","domHandler","ev","enable","init","evEl","evTarget","evWin","destroy","createInputInstance","Type","inputClass","PointerEventInput","TouchInput","MouseInput","TouchMouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","x","overallVelocityY","y","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","last","lastInterval","velocity","velocityX","velocityY","direction","v","clientX","clientY","p1","p2","props","sqrt","atan2","PI","start","end","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","pressed","MEhandler","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","store","pointerEvents","PEhandler","removePointer","eventTypeNormalized","toLowerCase","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","TEhandler","touches","normalizeSingleTouches","changed","changedTouches","concat","TOUCH_INPUT_MAP","TOUCH_TARGET_EVENTS","targetIds","MTEhandler","getTouches","allTouches","identifier","targetTouches","changedTargetTouches","filter","touch","DEDUP_TIMEOUT","DEDUP_DISTANCE","mouse","primaryTouch","lastTouches","TMEhandler","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","recordTouches","isSyntheticEvent","eventData","setLastTouch","lastTouch","lts","removeLastTouch","t","dx","dy","PREFIXED_TOUCH_ACTION","style","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","getTouchActionProps","TouchAction","value","set","compute","actions","update","touchAction","recognizers","recognizer","getTouchAction","cleanTouchActions","join","preventDefaults","prevented","preventDefault","hasNone","hasPanY","hasPanX","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","touchMap","cssSupports","CSS","supports","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Recognizer","defaults","id","state","simultaneous","requireFail","recognizeWith","otherRecognizer","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","self","event","stateStr","additionalEvent","tryEmit","canEmit","inputDataClone","reset","process","directionStr","get","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","pX","pY","threshold","directionTest","hasMoved","PinchRecognizer","inOut","PressRecognizer","_timer","_input","time","validPointers","validMovement","validTime","clearTimeout","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","Hammer","preset","Manager","VERSION","domEvents","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","handlers","oldCssProps","toggleCssProps","item","add","stop","force","stopped","curRecognizer","existing","remove","on","events","off","data","triggerDomEvent","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","Tap","Pan","Swipe","Pinch","Rotate","Press","freeGlobal","define","amd"],"mappings":"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","sourcesContent":["/** @module external.hammer */require( 'external.hammer', function(require, module, exports) { var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\n   'use strict';\n\n/**\n * ! Hammer.JS - v2.0.8 - 2016-04-23\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n\n/* eslint max-statements: [\"error\", 20, { \"ignoreTopLevelFunctions\": true }] */\n/* eslint wrap-iife: 0 */\n( function ( window, document, exportName, undefined ) {\n    const\n        VENDOR_PREFIXES = [ '', 'webkit', 'Moz', 'MS', 'ms', 'o' ],\n        TEST_ELEMENT = document.createElement( 'div' ),\n        TYPE_FUNCTION = 'function';\n\n    const\n        round = Math.round,\n        abs = Math.abs,\n        now = Date.now;\n\n    /**\n     * set a timeout with a given scope\n     * @param {Function} fn\n     * @param {Number} timeout\n     * @param {Object} context\n     * @returns {number}\n     */\n    function setTimeoutContext( fn, timeout, context ) {\n        return setTimeout( bindFn( fn, context ), timeout );\n    }\n\n    /**\n     * if the argument is an array, we want to execute the fn on each entry\n     * if it aint an array we don't want to do a thing.\n     * this is used by all the methods that accept a single and array argument.\n     * @param {*|Array} arg\n     * @param {String} fn\n     * @param {Object} [context]\n     * @returns {Boolean}\n     */\n    function invokeArrayArg( arg, fn, context ) {\n        if ( Array.isArray( arg ) ) {\n            each( arg, context[ fn ], context );\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * walk objects and arrays\n     * @param {Object} obj\n     * @param {Function} iterator\n     * @param {Object} context\n     */\n    function each( obj, iterator, context ) {\n        var i;\n\n        if ( !obj ) {\n            return;\n        }\n\n        if ( obj.forEach ) {\n            obj.forEach( iterator, context );\n        } else if ( obj.length !== undefined ) {\n            i = 0;\n            while ( i < obj.length ) {\n                iterator.call( context, obj[ i ], i, obj );\n                i++;\n            }\n        } else {\n            for ( i in obj ) {\n                obj.hasOwnProperty( i ) && iterator.call( context, obj[ i ], i, obj );\n            }\n        }\n    }\n\n    /**\n     * wrap a method with a deprecation warning and stack trace\n     * @param {Function} method\n     * @param {String} name\n     * @param {String} message\n     * @returns {Function} A new function wrapping the supplied method.\n     */\n    function deprecate( method, name, message ) {\n        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n        return function () {\n            var e = new Error( 'get-stack-trace' );\n            var stack = e && e.stack ? e.stack.replace( /^[^\\(]+?[\\n$]/gm, '' )\n                .replace( /^\\s+at\\s+/gm, '' )\n                .replace( /^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@' ) : 'Unknown Stack Trace';\n\n            var log = window.console && ( window.console.warn || window.console.log );\n            if ( log ) {\n                log.call( window.console, deprecationMessage, stack );\n            }\n            return method.apply( this, arguments );\n        };\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} target\n     * @param {...Object} objects_to_assign\n     * @returns {Object} target\n     */\n    let assign;\n    if ( typeof Object.assign !== 'function' ) {\n        assign = function assign( target ) {\n            if ( target === undefined || target === null ) {\n                throw new TypeError( 'Cannot convert undefined or null to object' );\n            }\n\n            var output = Object( target );\n            for ( var index = 1; index < arguments.length; index++ ) {\n                var source = arguments[ index ];\n                if ( source !== undefined && source !== null ) {\n                    for ( var nextKey in source ) {\n                        if ( source.hasOwnProperty( nextKey ) ) {\n                            output[ nextKey ] = source[ nextKey ];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    } else {\n        assign = Object.assign;\n    }\n\n    /**\n     * extend object.\n     * means that properties in dest will be overwritten by the ones in src.\n     * @param {Object} dest\n     * @param {Object} src\n     * @param {Boolean} [merge=false]\n     * @returns {Object} dest\n     */\n    var extend = deprecate( function extend( dest, src, merge ) {\n        var keys = Object.keys( src );\n        var i = 0;\n        while ( i < keys.length ) {\n            if ( !merge || ( merge && dest[ keys[ i ] ] === undefined ) ) {\n                dest[ keys[ i ] ] = src[ keys[ i ] ];\n            }\n            i++;\n        }\n        return dest;\n    }, 'extend', 'Use `assign`.' );\n\n    /**\n     * merge the values from src in the dest.\n     * means that properties that exist in dest will not be overwritten by src\n     * @param {Object} dest\n     * @param {Object} src\n     * @returns {Object} dest\n     */\n    var merge = deprecate( function merge( dest, src ) {\n        return extend( dest, src, true );\n    }, 'merge', 'Use `assign`.' );\n\n    /**\n     * simple class inheritance\n     * @param {Function} child\n     * @param {Function} base\n     * @param {Object} [properties]\n     */\n    function inherit( child, base, properties ) {\n        const\n            baseP = base.prototype,\n            childP = child.prototype = Object.create( baseP );\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if ( properties ) {\n            assign( childP, properties );\n        }\n    }\n\n    /**\n     * simple function bind\n     * @param {Function} fn\n     * @param {Object} context\n     * @returns {Function}\n     */\n    function bindFn( fn, context ) {\n        return function boundFn() {\n            return fn.apply( context, arguments );\n        };\n    }\n\n    /**\n     * let a boolean value also be a function that must return a boolean\n     * this first item in args will be used as the context\n     * @param {Boolean|Function} val\n     * @param {Array} [args]\n     * @returns {Boolean}\n     */\n    function boolOrFn( val, args ) {\n        if ( typeof val == TYPE_FUNCTION ) {\n            return val.apply( args ? args[ 0 ] || undefined : undefined, args );\n        }\n        return val;\n    }\n\n    /**\n     * use the val2 when val1 is undefined\n     * @param {*} val1\n     * @param {*} val2\n     * @returns {*}\n     */\n    function ifUndefined( val1, val2 ) {\n        return ( val1 === undefined ) ? val2 : val1;\n    }\n\n    /**\n     * addEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function addEventListeners( target, types, handler ) {\n        each( splitStr( types ), function ( type ) {\n            target.addEventListener( type, handler, false );\n        } );\n    }\n\n    /**\n     * removeEventListener with multiple events at once\n     * @param {EventTarget} target\n     * @param {String} types\n     * @param {Function} handler\n     */\n    function removeEventListeners( target, types, handler ) {\n        each( splitStr( types ), function ( type ) {\n            target.removeEventListener( type, handler, false );\n        } );\n    }\n\n    /**\n     * find if a node is in the given parent\n     * @method hasParent\n     * @param {HTMLElement} node\n     * @param {HTMLElement} parent\n     * @return {Boolean} found\n     */\n    function hasParent( node, parent ) {\n        while ( node ) {\n            if ( node == parent ) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * small indexOf wrapper\n     * @param {String} str\n     * @param {String} find\n     * @returns {Boolean} found\n     */\n    function inStr( str, find ) {\n        return str.indexOf( find ) > -1;\n    }\n\n    /**\n     * split string on whitespace\n     * @param {String} str\n     * @returns {Array} words\n     */\n    function splitStr( str ) {\n        return str.trim().split( /\\s+/g );\n    }\n\n    /**\n     * find if a array contains the object using indexOf or a simple polyFill\n     * @param {Array} src\n     * @param {String} find\n     * @param {String} [findByKey]\n     * @return {Boolean|Number} false when not found, or the index\n     */\n    function inArray( src, find, findByKey ) {\n        if ( src.indexOf && !findByKey ) {\n            return src.indexOf( find );\n        } else {\n            var i = 0;\n            while ( i < src.length ) {\n                if ( ( findByKey && src[ i ][ findByKey ] == find ) || ( !findByKey && src[ i ] === find ) ) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * convert array-like objects to real arrays\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    function toArray( obj ) {\n        return Array.prototype.slice.call( obj, 0 );\n    }\n\n    /**\n     * unique array with objects based on a key (like 'id') or just by the array's value\n     * @param {Array} src [{id:1},{id:2},{id:1}]\n     * @param {String} [key]\n     * @param {Boolean} [sort=False]\n     * @returns {Array} [{id:1},{id:2}]\n     */\n    function uniqueArray( src, key, sort ) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while ( i < src.length ) {\n            var val = key ? src[ i ][ key ] : src[ i ];\n            if ( inArray( values, val ) < 0 ) {\n                results.push( src[ i ] );\n            }\n            values[ i ] = val;\n            i++;\n        }\n\n        if ( sort ) {\n            if ( !key ) {\n                results = results.sort();\n            } else {\n                results = results.sort( function sortUniqueArray( a, b ) {\n                    return a[ key ] > b[ key ];\n                } );\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * get the prefixed property\n     * @param {Object} obj\n     * @param {String} property\n     * @returns {String|Undefined} prefixed\n     */\n    function prefixed( obj, property ) {\n        const camelProp = property[ 0 ].toUpperCase() + property.slice( 1 );\n\n        let i = 0;\n        while ( i < VENDOR_PREFIXES.length ) {\n            const\n                prefix = VENDOR_PREFIXES[ i ],\n                prop = ( prefix ) ? prefix + camelProp : property;\n\n            if ( prop in obj ) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\n     * get a unique id\n     * @returns {number} uniqueId\n     */\n    let _uniqueId = 1;\n\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\n     * get the window object of an element\n     * @param {HTMLElement} element\n     * @returns {DocumentView|Window}\n     */\n    function getWindowForElement( element ) {\n        var doc = element.ownerDocument || element;\n        return ( doc.defaultView || doc.parentWindow || window );\n    }\n\n    const MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    const\n        SUPPORT_TOUCH = ( 'ontouchstart' in window ),\n        SUPPORT_POINTER_EVENTS = prefixed( window, 'PointerEvent' ) !== undefined,\n        SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test( navigator.userAgent );\n\n    const\n        INPUT_TYPE_TOUCH = 'touch',\n        INPUT_TYPE_PEN = 'pen',\n        INPUT_TYPE_MOUSE = 'mouse',\n        INPUT_TYPE_KINECT = 'kinect';\n\n    const COMPUTE_INTERVAL = 25;\n\n    const\n        INPUT_START = 1,\n        INPUT_MOVE = 2,\n        INPUT_END = 4,\n        INPUT_CANCEL = 8;\n\n    const\n        DIRECTION_NONE = 1,\n        DIRECTION_LEFT = 2,\n        DIRECTION_RIGHT = 4,\n        DIRECTION_UP = 8,\n        DIRECTION_DOWN = 16;\n\n    const\n        DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT,\n        DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN,\n        DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    const\n        PROPS_XY = [ 'x', 'y' ],\n        PROPS_CLIENT_XY = [ 'clientX', 'clientY' ];\n\n    /**\n     * create new input type manager\n     * @param {Manager} manager\n     * @param {Function} callback\n     * @returns {Input}\n     * @constructor\n     */\n    function Input( manager, callback ) {\n        const that = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function ( ev ) {\n            if ( boolOrFn( manager.options.enable, [ manager ] ) ) {\n                that.handler( ev );\n            }\n        };\n\n        this.init();\n    }\n\n    Input.prototype = {\n        /**\n         * should handle the inputEvent data and trigger the callback\n         * @virtual\n         */\n        handler() {},\n\n        /**\n         * bind the events\n         */\n        init() {\n            this.evEl && addEventListeners( this.element, this.evEl, this.domHandler );\n            this.evTarget && addEventListeners( this.target, this.evTarget, this.domHandler );\n            this.evWin && addEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );\n        },\n\n        /**\n         * unbind the events\n         */\n        destroy() {\n            this.evEl && removeEventListeners( this.element, this.evEl, this.domHandler );\n            this.evTarget && removeEventListeners( this.target, this.evTarget, this.domHandler );\n            this.evWin && removeEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );\n        }\n    };\n\n    /**\n     * create new input type manager\n     * called by the Manager constructor\n     * @param {Hammer} manager\n     * @returns {Input}\n     */\n    function createInputInstance( manager ) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if ( inputClass ) {\n            Type = inputClass;\n        } else if ( SUPPORT_POINTER_EVENTS ) {\n            Type = PointerEventInput;\n        } else if ( SUPPORT_ONLY_TOUCH ) {\n            Type = TouchInput;\n        } else if ( !SUPPORT_TOUCH ) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new( Type )( manager, inputHandler );\n    }\n\n    /**\n     * handle input events\n     * @param {Manager} manager\n     * @param {String} eventType\n     * @param {Object} input\n     */\n    function inputHandler( manager, eventType, input ) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = ( eventType & INPUT_START && ( pointersLen - changedPointersLen === 0 ) );\n        var isFinal = ( eventType & ( INPUT_END | INPUT_CANCEL ) && ( pointersLen - changedPointersLen === 0 ) );\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if ( isFirst ) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData( manager, input );\n\n        // emit secret event\n        manager.emit( 'hammer.input', input );\n\n        manager.recognize( input );\n        manager.session.prevInput = input;\n    }\n\n    /**\n     * extend the data with some usable properties like scale, rotate, velocity etc\n     * @param {Object} manager\n     * @param {Object} input\n     */\n    function computeInputData( manager, input ) {\n        const\n            session = manager.session,\n            pointers = input.pointers,\n            pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if ( !session.firstInput ) {\n            session.firstInput = simpleCloneInputData( input );\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if ( pointersLength > 1 && !session.firstMultiple ) {\n            session.firstMultiple = simpleCloneInputData( input );\n        } else if ( pointersLength === 1 ) {\n            session.firstMultiple = false;\n        }\n\n        const\n            firstInput = session.firstInput,\n            firstMultiple = session.firstMultiple,\n            offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        const center = input.center = getCenter( pointers );\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle( offsetCenter, center );\n        input.distance = getDistance( offsetCenter, center );\n\n        computeDeltaXY( session, input );\n        input.offsetDirection = getDirection( input.deltaX, input.deltaY );\n\n        const overallVelocity = getVelocity( input.deltaTime, input.deltaX, input.deltaY );\n        input.overallVelocityX = overallVelocity.x;\n        input.overallVelocityY = overallVelocity.y;\n        input.overallVelocity = ( abs( overallVelocity.x ) > abs( overallVelocity.y ) ) ? overallVelocity.x : overallVelocity.y;\n\n        input.scale = firstMultiple ? getScale( firstMultiple.pointers, pointers ) : 1;\n        input.rotation = firstMultiple ? getRotation( firstMultiple.pointers, pointers ) : 0;\n\n        input.maxPointers = !session.prevInput ? input.pointers.length : ( ( input.pointers.length >\n            session.prevInput.maxPointers ) ? input.pointers.length : session.prevInput.maxPointers );\n\n        computeIntervalInputData( session, input );\n\n        // find the correct target\n        var target = manager.element;\n        if ( hasParent( input.srcEvent.target, target ) ) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY( session, input ) {\n        let\n            center = input.center,\n            offset = session.offsetDelta || {},\n            prevDelta = session.prevDelta || {},\n            prevInput = session.prevInput || {};\n\n        if ( input.eventType === INPUT_START || prevInput.eventType === INPUT_END ) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + ( center.x - offset.x );\n        input.deltaY = prevDelta.y + ( center.y - offset.y );\n    }\n\n    /**\n     * velocity is calculated every x ms\n     * @param {Object} session\n     * @param {Object} input\n     */\n    function computeIntervalInputData( session, input ) {\n        const\n            last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp;\n        let velocity, velocityX, velocityY, direction;\n\n        if ( input.eventType !== INPUT_CANCEL && ( deltaTime > COMPUTE_INTERVAL || last.velocity === undefined ) ) {\n            const\n                deltaX = input.deltaX - last.deltaX,\n                deltaY = input.deltaY - last.deltaY,\n                v = getVelocity( deltaTime, deltaX, deltaY );\n\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = ( abs( v.x ) > abs( v.y ) ) ? v.x : v.y;\n            direction = getDirection( deltaX, deltaY );\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\n     * @param {Object} input\n     * @returns {Object} clonedInputData\n     */\n    function simpleCloneInputData( input ) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while ( i < input.pointers.length ) {\n            pointers[ i ] = {\n                clientX: round( input.pointers[ i ].clientX ),\n                clientY: round( input.pointers[ i ].clientY )\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter( pointers ),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\n     * get the center of all the pointers\n     * @param {Array} pointers\n     * @return {Object} center contains `x` and `y` properties\n     */\n    function getCenter( pointers ) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if ( pointersLength === 1 ) {\n            return {\n                x: round( pointers[ 0 ].clientX ),\n                y: round( pointers[ 0 ].clientY )\n            };\n        }\n\n        var x = 0,\n            y = 0,\n            i = 0;\n        while ( i < pointersLength ) {\n            x += pointers[ i ].clientX;\n            y += pointers[ i ].clientY;\n            i++;\n        }\n\n        return {\n            x: round( x / pointersLength ),\n            y: round( y / pointersLength )\n        };\n    }\n\n    /**\n     * calculate the velocity between two points. unit is in px per ms.\n     * @param {Number} deltaTime\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Object} velocity `x` and `y`\n     */\n    function getVelocity( deltaTime, x, y ) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\n     * get the direction between two points\n     * @param {Number} x\n     * @param {Number} y\n     * @return {Number} direction\n     */\n    function getDirection( x, y ) {\n        if ( x === y ) {\n            return DIRECTION_NONE;\n        }\n\n        if ( abs( x ) >= abs( y ) ) {\n            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\n     * calculate the absolute distance between two points\n     * @param {Object} p1 {x, y}\n     * @param {Object} p2 {x, y}\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} distance\n     */\n    function getDistance( p1, p2, props ) {\n        if ( !props ) {\n            props = PROPS_XY;\n        }\n        var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],\n            y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];\n\n        return Math.sqrt( ( x * x ) + ( y * y ) );\n    }\n\n    /**\n     * calculate the angle between two coordinates\n     * @param {Object} p1\n     * @param {Object} p2\n     * @param {Array} [props] containing x and y keys\n     * @return {Number} angle\n     */\n    function getAngle( p1, p2, props ) {\n        if ( !props ) {\n            props = PROPS_XY;\n        }\n        var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],\n            y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];\n        return Math.atan2( y, x ) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the rotation degrees between two pointersets\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} rotation\n     */\n    function getRotation( start, end ) {\n        return getAngle( end[ 1 ], end[ 0 ], PROPS_CLIENT_XY ) + getAngle( start[ 1 ], start[ 0 ], PROPS_CLIENT_XY );\n    }\n\n    /**\n     * calculate the scale factor between two pointersets\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param {Array} start array of pointers\n     * @param {Array} end array of pointers\n     * @return {Number} scale\n     */\n    function getScale( start, end ) {\n        return getDistance( end[ 0 ], end[ 1 ], PROPS_CLIENT_XY ) / getDistance( start[ 0 ], start[ 1 ], PROPS_CLIENT_XY );\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\n     * Mouse events input\n     * @constructor\n     * @extends Input\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.pressed = false; // mousedown state\n\n        Input.apply( this, arguments );\n    }\n\n    inherit( MouseInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function MEhandler( ev ) {\n            var eventType = MOUSE_INPUT_MAP[ ev.type ];\n\n            // on start we want to have the left mouse button down\n            if ( eventType & INPUT_START && ev.button !== 2 ) {\n                this.pressed = true;\n            }\n\n            if ( eventType & INPUT_MOVE && ev.which !== 1 ) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down\n            if ( !this.pressed ) {\n                return;\n            }\n\n            if ( eventType & INPUT_END ) {\n                this.pressed = false;\n            }\n\n            this.callback( this.manager, eventType, {\n                pointers: [ ev ],\n                changedPointers: [ ev ],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            } );\n        }\n    } );\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n    // in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n    // IE10 has prefixed support, and case-sensitive\n    if ( window.MSPointerEvent && !window.PointerEvent ) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\n     * Pointer events input\n     * @constructor\n     * @extends Input\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply( this, arguments );\n\n        this.store = ( this.manager.session.pointerEvents = [] );\n    }\n\n    inherit( PointerEventInput, Input, {\n        /**\n         * handle mouse events\n         * @param {Object} ev\n         */\n        handler: function PEhandler( ev ) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace( 'ms', '' );\n            var eventType = POINTER_INPUT_MAP[ eventTypeNormalized ];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ ev.pointerType ] || ev.pointerType;\n\n            var isTouch = ( pointerType == INPUT_TYPE_TOUCH );\n\n            // get index of the event in the store\n            var storeIndex = inArray( store, ev.pointerId, 'pointerId' );\n\n            // start and mouse must be down\n            if ( eventType & INPUT_START && ( ev.button !== 2 || isTouch ) ) {\n                if ( storeIndex < 0 ) {\n                    store.push( ev );\n                    storeIndex = store.length - 1;\n                }\n            } else if ( eventType & ( INPUT_END | INPUT_CANCEL ) ) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if ( storeIndex < 0 ) {\n                return;\n            }\n\n            // update the event in the store\n            store[ storeIndex ] = ev;\n\n            this.callback( this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ ev ],\n                pointerType: pointerType,\n                srcEvent: ev\n            } );\n\n            if ( removePointer ) {\n                // remove from the store\n                store.splice( storeIndex, 1 );\n            }\n        }\n    } );\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Touch events input\n     * @constructor\n     * @extends Input\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply( this, arguments );\n    }\n\n    inherit( SingleTouchInput, Input, {\n        handler: function TEhandler( ev ) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ ev.type ];\n\n            // should we handle the touch events?\n            if ( type === INPUT_START ) {\n                this.started = true;\n            }\n\n            if ( !this.started ) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call( this, ev, type );\n\n            // when done, reset the started state\n            if ( type & ( INPUT_END | INPUT_CANCEL ) && touches[ 0 ].length - touches[ 1 ].length === 0 ) {\n                this.started = false;\n            }\n\n            this.callback( this.manager, type, {\n                pointers: touches[ 0 ],\n                changedPointers: touches[ 1 ],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            } );\n        }\n    } );\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function normalizeSingleTouches( ev, type ) {\n        var all = toArray( ev.touches );\n        var changed = toArray( ev.changedTouches );\n\n        if ( type & ( INPUT_END | INPUT_CANCEL ) ) {\n            all = uniqueArray( all.concat( changed ), 'identifier', true );\n        }\n\n        return [ all, changed ];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\n     * Multi-user touch events input\n     * @constructor\n     * @extends Input\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply( this, arguments );\n    }\n\n    inherit( TouchInput, Input, {\n        handler: function MTEhandler( ev ) {\n            var type = TOUCH_INPUT_MAP[ ev.type ];\n            var touches = getTouches.call( this, ev, type );\n            if ( !touches ) {\n                return;\n            }\n\n            this.callback( this.manager, type, {\n                pointers: touches[ 0 ],\n                changedPointers: touches[ 1 ],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            } );\n        }\n    } );\n\n    /**\n     * @this {TouchInput}\n     * @param {Object} ev\n     * @param {Number} type flag\n     * @returns {undefined|Array} [all, changed]\n     */\n    function getTouches( ev, type ) {\n        var allTouches = toArray( ev.touches );\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if ( type & ( INPUT_START | INPUT_MOVE ) && allTouches.length === 1 ) {\n            targetIds[ allTouches[ 0 ].identifier ] = true;\n            return [ allTouches, allTouches ];\n        }\n\n        var i,\n            targetTouches,\n            changedTouches = toArray( ev.changedTouches ),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter( function ( touch ) {\n            return hasParent( touch.target, target );\n        } );\n\n        // collect touches\n        if ( type === INPUT_START ) {\n            i = 0;\n            while ( i < targetTouches.length ) {\n                targetIds[ targetTouches[ i ].identifier ] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while ( i < changedTouches.length ) {\n            if ( targetIds[ changedTouches[ i ].identifier ] ) {\n                changedTargetTouches.push( changedTouches[ i ] );\n            }\n\n            // cleanup removed touches\n            if ( type & ( INPUT_END | INPUT_CANCEL ) ) {\n                delete targetIds[ changedTouches[ i ].identifier ];\n            }\n            i++;\n        }\n\n        if ( !changedTargetTouches.length ) {\n            return;\n        }\n\n        return [\n            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n            uniqueArray( targetTouches.concat( changedTargetTouches ), 'identifier', true ),\n            changedTargetTouches\n        ];\n    }\n\n    /**\n     * Combined touch and mouse input\n     *\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n     * This because touch devices also emit mouse events while doing a touch.\n     *\n     * @constructor\n     * @extends Input\n     */\n\n    var DEDUP_TIMEOUT = 2500;\n    var DEDUP_DISTANCE = 25;\n\n    function TouchMouseInput() {\n        Input.apply( this, arguments );\n\n        var handler = bindFn( this.handler, this );\n        this.touch = new TouchInput( this.manager, handler );\n        this.mouse = new MouseInput( this.manager, handler );\n\n        this.primaryTouch = null;\n        this.lastTouches = [];\n    }\n\n    inherit( TouchMouseInput, Input, {\n        /**\n         * handle mouse and touch events\n         * @param {Hammer} manager\n         * @param {String} inputEvent\n         * @param {Object} inputData\n         */\n        handler: function TMEhandler( manager, inputEvent, inputData ) {\n            var isTouch = ( inputData.pointerType == INPUT_TYPE_TOUCH ),\n                isMouse = ( inputData.pointerType == INPUT_TYPE_MOUSE );\n\n            if ( isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents ) {\n                return;\n            }\n\n            // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n            if ( isTouch ) {\n                recordTouches.call( this, inputEvent, inputData );\n            } else if ( isMouse && isSyntheticEvent.call( this, inputData ) ) {\n                return;\n            }\n\n            this.callback( manager, inputEvent, inputData );\n        },\n\n        /**\n         * remove the event listeners\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    } );\n\n    function recordTouches( eventType, eventData ) {\n        if ( eventType & INPUT_START ) {\n            this.primaryTouch = eventData.changedPointers[ 0 ].identifier;\n            setLastTouch.call( this, eventData );\n        } else if ( eventType & ( INPUT_END | INPUT_CANCEL ) ) {\n            setLastTouch.call( this, eventData );\n        }\n    }\n\n    function setLastTouch( eventData ) {\n        var touch = eventData.changedPointers[ 0 ];\n\n        if ( touch.identifier === this.primaryTouch ) {\n            var lastTouch = { x: touch.clientX, y: touch.clientY };\n            this.lastTouches.push( lastTouch );\n            var lts = this.lastTouches;\n            var removeLastTouch = function () {\n                var i = lts.indexOf( lastTouch );\n                if ( i > -1 ) {\n                    lts.splice( i, 1 );\n                }\n            };\n            setTimeout( removeLastTouch, DEDUP_TIMEOUT );\n        }\n    }\n\n    function isSyntheticEvent( eventData ) {\n        var x = eventData.srcEvent.clientX,\n            y = eventData.srcEvent.clientY;\n        for ( var i = 0; i < this.lastTouches.length; i++ ) {\n            var t = this.lastTouches[ i ];\n            var dx = Math.abs( x - t.x ),\n                dy = Math.abs( y - t.y );\n            if ( dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var PREFIXED_TOUCH_ACTION = prefixed( TEST_ELEMENT.style, 'touchAction' );\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n    // magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n    var TOUCH_ACTION_MAP = getTouchActionProps();\n\n    /**\n     * Touch Action\n     * sets the touchAction property or uses the js alternative\n     * @param {Manager} manager\n     * @param {String} value\n     * @constructor\n     */\n    function TouchAction( manager, value ) {\n        this.manager = manager;\n        this.set( value );\n    }\n\n    TouchAction.prototype = {\n        /**\n         * set the touchAction value on the element or enable the polyfill\n         * @param {String} value\n         */\n        set: function ( value ) {\n            // find out the touch-action by the event handlers\n            if ( value == TOUCH_ACTION_COMPUTE ) {\n                value = this.compute();\n            }\n\n            if ( NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[ value ] ) {\n                this.manager.element.style[ PREFIXED_TOUCH_ACTION ] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\n         * just re-set the touchAction value\n         */\n        update: function () {\n            this.set( this.manager.options.touchAction );\n        },\n\n        /**\n         * compute the value for the touchAction property based on the recognizer's settings\n         * @returns {String} value\n         */\n        compute: function () {\n            var actions = [];\n            each( this.manager.recognizers, function ( recognizer ) {\n                if ( boolOrFn( recognizer.options.enable, [ recognizer ] ) ) {\n                    actions = actions.concat( recognizer.getTouchAction() );\n                }\n            } );\n            return cleanTouchActions( actions.join( ' ' ) );\n        },\n\n        /**\n         * this method is called on each input cycle and provides the preventing of the browser behavior\n         * @param {Object} input\n         */\n        preventDefaults: function ( input ) {\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if ( this.manager.session.prevented ) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr( actions, TOUCH_ACTION_NONE ) && !TOUCH_ACTION_MAP[ TOUCH_ACTION_NONE ];\n            var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y ) && !TOUCH_ACTION_MAP[ TOUCH_ACTION_PAN_Y ];\n            var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X ) && !TOUCH_ACTION_MAP[ TOUCH_ACTION_PAN_X ];\n\n            if ( hasNone ) {\n                //do not prevent defaults if this is a tap gesture\n\n                var isTapPointer = input.pointers.length === 1;\n                var isTapMovement = input.distance < 2;\n                var isTapTouchTime = input.deltaTime < 250;\n\n                if ( isTapPointer && isTapMovement && isTapTouchTime ) {\n                    return;\n                }\n            }\n\n            if ( hasPanX && hasPanY ) {\n                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                return;\n            }\n\n            if ( hasNone ||\n                ( hasPanY && direction & DIRECTION_HORIZONTAL ) ||\n                ( hasPanX && direction & DIRECTION_VERTICAL ) ) {\n                return this.preventSrc( srcEvent );\n            }\n        },\n\n        /**\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n         * @param {Object} srcEvent\n         */\n        preventSrc: function ( srcEvent ) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n     * @param {String} actions\n     * @returns {*}\n     */\n    function cleanTouchActions( actions ) {\n        // none\n        if ( inStr( actions, TOUCH_ACTION_NONE ) ) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X );\n        var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y );\n\n        // if both pan-x and pan-y are set (different recognizers\n        // for different directions, e.g. horizontal pan but vertical swipe?)\n        // we need none (as otherwise with pan-x pan-y combined none of these\n        // recognizers will work, since the browser would handle all panning\n        if ( hasPanX && hasPanY ) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        // pan-x OR pan-y\n        if ( hasPanX || hasPanY ) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if ( inStr( actions, TOUCH_ACTION_MANIPULATION ) ) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    function getTouchActionProps() {\n        if ( !NATIVE_TOUCH_ACTION ) {\n            return false;\n        }\n        var touchMap = {};\n        var cssSupports = window.CSS && window.CSS.supports;\n        [ 'auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none' ].forEach( function ( val ) {\n\n            // If css.supports is not supported but there is native touch-action assume it supports\n            // all values. This is the case for IE 10 and 11.\n            touchMap[ val ] = cssSupports ? window.CSS.supports( 'touch-action', val ) : true;\n        } );\n        return touchMap;\n    }\n\n    /**\n     * Recognizer flow explained; *\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\n     *\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n     * which determines with state it should be.\n     *\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n     * POSSIBLE to give it another change on the next cycle.\n     *\n     *               Possible\n     *                  |\n     *            +-----+---------------+\n     *            |                     |\n     *      +-----+-----+               |\n     *      |           |               |\n     *   Failed      Cancelled          |\n     *                          +-------+------+\n     *                          |              |\n     *                      Recognized       Began\n     *                                         |\n     *                                      Changed\n     *                                         |\n     *                                  Ended/Recognized\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\n     * Recognizer\n     * Every recognizer needs to extend from this class.\n     * @constructor\n     * @param {Object} options\n     */\n    function Recognizer( options ) {\n        this.options = assign( {}, this.defaults, options || {} );\n\n        this.id = uniqueId();\n\n        this.manager = null;\n\n        // default is enable true\n        this.options.enable = ifUndefined( this.options.enable, true );\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\n         * @virtual\n         * @type {Object}\n         */\n        defaults: {},\n\n        /**\n         * set options\n         * @param {Object} options\n         * @return {Recognizer}\n         */\n        set: function ( options ) {\n            assign( this.options, options );\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\n         * recognize simultaneous with an other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        recognizeWith: function ( otherRecognizer ) {\n            if ( invokeArrayArg( otherRecognizer, 'recognizeWith', this ) ) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );\n            if ( !simultaneous[ otherRecognizer.id ] ) {\n                simultaneous[ otherRecognizer.id ] = otherRecognizer;\n                otherRecognizer.recognizeWith( this );\n            }\n            return this;\n        },\n\n        /**\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRecognizeWith: function ( otherRecognizer ) {\n            if ( invokeArrayArg( otherRecognizer, 'dropRecognizeWith', this ) ) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );\n            delete this.simultaneous[ otherRecognizer.id ];\n            return this;\n        },\n\n        /**\n         * recognizer can only run when an other is failing\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        requireFailure: function ( otherRecognizer ) {\n            if ( invokeArrayArg( otherRecognizer, 'requireFailure', this ) ) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );\n            if ( inArray( requireFail, otherRecognizer ) === -1 ) {\n                requireFail.push( otherRecognizer );\n                otherRecognizer.requireFailure( this );\n            }\n            return this;\n        },\n\n        /**\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\n         * @param {Recognizer} otherRecognizer\n         * @returns {Recognizer} this\n         */\n        dropRequireFailure: function ( otherRecognizer ) {\n            if ( invokeArrayArg( otherRecognizer, 'dropRequireFailure', this ) ) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );\n            var index = inArray( this.requireFail, otherRecognizer );\n            if ( index > -1 ) {\n                this.requireFail.splice( index, 1 );\n            }\n            return this;\n        },\n\n        /**\n         * has require failures boolean\n         * @returns {boolean}\n         */\n        hasRequireFailures: function () {\n            return this.requireFail.length > 0;\n        },\n\n        /**\n         * if the recognizer can recognize simultaneous with an other recognizer\n         * @param {Recognizer} otherRecognizer\n         * @returns {Boolean}\n         */\n        canRecognizeWith: function ( otherRecognizer ) {\n            return !!this.simultaneous[ otherRecognizer.id ];\n        },\n\n        /**\n         * You should use `tryEmit` instead of `emit` directly to check\n         * that all the needed recognizers has failed before emitting.\n         * @param {Object} input\n         */\n        emit: function ( input ) {\n            var self = this;\n            var state = this.state;\n\n            function emit( event ) {\n                self.manager.emit( event, input );\n            }\n\n            // 'panstart' and 'panmove'\n            if ( state < STATE_ENDED ) {\n                emit( self.options.event + stateStr( state ) );\n            }\n\n            emit( self.options.event ); // simple 'eventName' events\n\n            if ( input.additionalEvent ) { // additional event(panleft, panright, pinchin, pinchout...)\n                emit( input.additionalEvent );\n            }\n\n            // panend and pancancel\n            if ( state >= STATE_ENDED ) {\n                emit( self.options.event + stateStr( state ) );\n            }\n        },\n\n        /**\n         * Check that all the require failure recognizers has failed,\n         * if true, it emits a gesture event,\n         * otherwise, setup the state to FAILED.\n         * @param {Object} input\n         */\n        tryEmit: function ( input ) {\n            if ( this.canEmit() ) {\n                return this.emit( input );\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\n         * can we emit?\n         * @returns {boolean}\n         */\n        canEmit: function () {\n            var i = 0;\n            while ( i < this.requireFail.length ) {\n                if ( !( this.requireFail[ i ].state & ( STATE_FAILED | STATE_POSSIBLE ) ) ) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\n         * update the recognizer\n         * @param {Object} inputData\n         */\n        recognize: function ( inputData ) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = assign( {}, inputData );\n\n            // is is enabled and allow recognizing?\n            if ( !boolOrFn( this.options.enable, [ this, inputDataClone ] ) ) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if ( this.state & ( STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED ) ) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process( inputDataClone );\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if ( this.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED ) ) {\n                this.tryEmit( inputDataClone );\n            }\n        },\n\n        /**\n         * return the state of the recognizer\n         * the actual recognizing happens in this method\n         * @virtual\n         * @param {Object} inputData\n         * @returns {Const} STATE\n         */\n        process: function ( inputData ) {}, // jshint ignore:line\n\n        /**\n         * return the preferred touch-action\n         * @virtual\n         * @returns {Array}\n         */\n        getTouchAction: function () {},\n\n        /**\n         * called when the gesture isn't allowed to recognize\n         * like when another is being recognized or it is disabled\n         * @virtual\n         */\n        reset: function () {}\n    };\n\n    /**\n     * get a usable string, used as event postfix\n     * @param {Const} state\n     * @returns {String} state\n     */\n    function stateStr( state ) {\n        if ( state & STATE_CANCELLED ) {\n            return 'cancel';\n        } else if ( state & STATE_ENDED ) {\n            return 'end';\n        } else if ( state & STATE_CHANGED ) {\n            return 'move';\n        } else if ( state & STATE_BEGAN ) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\n     * direction cons to string\n     * @param {Const} direction\n     * @returns {String}\n     */\n    function directionStr( direction ) {\n        if ( direction == DIRECTION_DOWN ) {\n            return 'down';\n        } else if ( direction == DIRECTION_UP ) {\n            return 'up';\n        } else if ( direction == DIRECTION_LEFT ) {\n            return 'left';\n        } else if ( direction == DIRECTION_RIGHT ) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\n     * get a recognizer by name if it is bound to a manager\n     * @param {Recognizer|String} otherRecognizer\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer}\n     */\n    function getRecognizerByNameIfManager( otherRecognizer, recognizer ) {\n        var manager = recognizer.manager;\n        if ( manager ) {\n            return manager.get( otherRecognizer );\n        }\n        return otherRecognizer;\n    }\n\n    /**\n     * This recognizer is just used as a base for the simple attribute recognizers.\n     * @constructor\n     * @extends Recognizer\n     */\n    function AttrRecognizer() {\n        Recognizer.apply( this, arguments );\n    }\n\n    inherit( AttrRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof AttrRecognizer\n         */\n        defaults: {\n            /**\n             * @type {Number}\n             * @default 1\n             */\n            pointers: 1\n        },\n\n        /**\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {Boolean} recognized\n         */\n        attrTest: function ( input ) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\n         * Process the input and return the state for the recognizer\n         * @memberof AttrRecognizer\n         * @param {Object} input\n         * @returns {*} State\n         */\n        process: function ( input ) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & ( STATE_BEGAN | STATE_CHANGED );\n            var isValid = this.attrTest( input );\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if ( isRecognized && ( eventType & INPUT_CANCEL || !isValid ) ) {\n                return state | STATE_CANCELLED;\n            } else if ( isRecognized || isValid ) {\n                if ( eventType & INPUT_END ) {\n                    return state | STATE_ENDED;\n                } else if ( !( state & STATE_BEGAN ) ) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    } );\n\n    /**\n     * Pan\n     * Recognized when the pointer is down and moved in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply( this, arguments );\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit( PanRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PanRecognizer\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function () {\n            var direction = this.options.direction;\n            var actions = [];\n            if ( direction & DIRECTION_HORIZONTAL ) {\n                actions.push( TOUCH_ACTION_PAN_Y );\n            }\n            if ( direction & DIRECTION_VERTICAL ) {\n                actions.push( TOUCH_ACTION_PAN_X );\n            }\n            return actions;\n        },\n\n        directionTest: function ( input ) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if ( !( direction & options.direction ) ) {\n                if ( options.direction & DIRECTION_HORIZONTAL ) {\n                    direction = ( x === 0 ) ? DIRECTION_NONE : ( x < 0 ) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs( input.deltaX );\n                } else {\n                    direction = ( y === 0 ) ? DIRECTION_NONE : ( y < 0 ) ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs( input.deltaY );\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function ( input ) {\n            return AttrRecognizer.prototype.attrTest.call( this, input ) &&\n                ( this.state & STATE_BEGAN || ( !( this.state & STATE_BEGAN ) && this.directionTest( input ) ) );\n        },\n\n        emit: function ( input ) {\n\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr( input.direction );\n\n            if ( direction ) {\n                input.additionalEvent = this.options.event + direction;\n            }\n            this._super.emit.call( this, input );\n        }\n    } );\n\n    /**\n     * Pinch\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply( this, arguments );\n    }\n\n    inherit( PinchRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function () {\n            return [ TOUCH_ACTION_NONE ];\n        },\n\n        attrTest: function ( input ) {\n            return this._super.attrTest.call( this, input ) &&\n                ( Math.abs( input.scale - 1 ) > this.options.threshold || this.state & STATE_BEGAN );\n        },\n\n        emit: function ( input ) {\n            if ( input.scale !== 1 ) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                input.additionalEvent = this.options.event + inOut;\n            }\n            this._super.emit.call( this, input );\n        }\n    } );\n\n    /**\n     * Press\n     * Recognized when the pointer is down for x ms without any movement.\n     * @constructor\n     * @extends Recognizer\n     */\n    function PressRecognizer() {\n        Recognizer.apply( this, arguments );\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit( PressRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PressRecognizer\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 251, // minimal time of the pointer to be pressed\n            threshold: 9 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function () {\n            return [ TOUCH_ACTION_AUTO ];\n        },\n\n        process: function ( input ) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if ( !validMovement || !validPointers || ( input.eventType & ( INPUT_END | INPUT_CANCEL ) && !validTime ) ) {\n                this.reset();\n            } else if ( input.eventType & INPUT_START ) {\n                this.reset();\n                this._timer = setTimeoutContext( function () {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this );\n            } else if ( input.eventType & INPUT_END ) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function () {\n            clearTimeout( this._timer );\n        },\n\n        emit: function ( input ) {\n            if ( this.state !== STATE_RECOGNIZED ) {\n                return;\n            }\n\n            if ( input && ( input.eventType & INPUT_END ) ) {\n                this.manager.emit( this.options.event + 'up', input );\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit( this.options.event, this._input );\n            }\n        }\n    } );\n\n    /**\n     * Rotate\n     * Recognized when two or more pointer are moving in a circular motion.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply( this, arguments );\n    }\n\n    inherit( RotateRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof RotateRecognizer\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function () {\n            return [ TOUCH_ACTION_NONE ];\n        },\n\n        attrTest: function ( input ) {\n            return this._super.attrTest.call( this, input ) &&\n                ( Math.abs( input.rotation ) > this.options.threshold || this.state & STATE_BEGAN );\n        }\n    } );\n\n    /**\n     * Swipe\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n     * @constructor\n     * @extends AttrRecognizer\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply( this, arguments );\n    }\n\n    inherit( SwipeRecognizer, AttrRecognizer, {\n        /**\n         * @namespace\n         * @memberof SwipeRecognizer\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.3,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function () {\n            return PanRecognizer.prototype.getTouchAction.call( this );\n        },\n\n        attrTest: function ( input ) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if ( direction & ( DIRECTION_HORIZONTAL | DIRECTION_VERTICAL ) ) {\n                velocity = input.overallVelocity;\n            } else if ( direction & DIRECTION_HORIZONTAL ) {\n                velocity = input.overallVelocityX;\n            } else if ( direction & DIRECTION_VERTICAL ) {\n                velocity = input.overallVelocityY;\n            }\n\n            return this._super.attrTest.call( this, input ) &&\n                direction & input.offsetDirection &&\n                input.distance > this.options.threshold &&\n                input.maxPointers == this.options.pointers &&\n                abs( velocity ) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function ( input ) {\n            var direction = directionStr( input.offsetDirection );\n            if ( direction ) {\n                this.manager.emit( this.options.event + direction, input );\n            }\n\n            this.manager.emit( this.options.event, input );\n        }\n    } );\n\n    /**\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n     * a single tap.\n     *\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n     * multi-taps being recognized.\n     * @constructor\n     * @extends Recognizer\n     */\n    function TapRecognizer() {\n        Recognizer.apply( this, arguments );\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit( TapRecognizer, Recognizer, {\n        /**\n         * @namespace\n         * @memberof PinchRecognizer\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 9, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function () {\n            return [ TOUCH_ACTION_MANIPULATION ];\n        },\n\n        process: function ( input ) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if ( ( input.eventType & INPUT_START ) && ( this.count === 0 ) ) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if ( validMovement && validTouchTime && validPointers ) {\n                if ( input.eventType != INPUT_END ) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? ( input.timeStamp - this.pTime < options.interval ) : true;\n                var validMultiTap = !this.pCenter || getDistance( this.pCenter, input.center ) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if ( !validMultiTap || !validInterval ) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if ( tapCount === 0 ) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if ( !this.hasRequireFailures() ) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext( function () {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this );\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function () {\n            this._timer = setTimeoutContext( function () {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this );\n            return STATE_FAILED;\n        },\n\n        reset: function () {\n            clearTimeout( this._timer );\n        },\n\n        emit: function () {\n            if ( this.state == STATE_RECOGNIZED ) {\n                this._input.tapCount = this.count;\n                this.manager.emit( this.options.event, this._input );\n            }\n        }\n    } );\n\n    /**\n     * Simple way to create a manager with a default set of recognizers.\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Hammer( element, options ) {\n        options = options || {};\n        options.recognizers = ifUndefined( options.recognizers, Hammer.defaults.preset );\n        return new Manager( element, options );\n    }\n\n    /**\n     * @const {string}\n     */\n    Hammer.VERSION = '2.0.8';\n\n    /**\n     * default settings\n     * @namespace\n     */\n    Hammer.defaults = {\n        /**\n         * set if DOM events are being triggered.\n         * But this is slower and unused by simple implementations, so disabled by default.\n         * @type {Boolean}\n         * @default false\n         */\n        domEvents: false,\n\n        /**\n         * The value for the touchAction property/fallback.\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\n         * @type {String}\n         * @default compute\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\n         * @type {Boolean}\n         * @default true\n         */\n        enable: true,\n\n        /**\n         * EXPERIMENTAL FEATURE -- can be removed/changed\n         * Change the parent input target element.\n         * If Null, then it is being set the to main element.\n         * @type {Null|EventTarget}\n         * @default null\n         */\n        inputTarget: null,\n\n        /**\n         * force an input class\n         * @type {Null|Function}\n         * @default null\n         */\n        inputClass: null,\n\n        /**\n         * Default recognizer setup when calling `Hammer()`\n         * When creating a new Manager these will be skipped.\n         * @type {Array}\n         */\n        preset: [\n            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n            [ RotateRecognizer, { enable: false } ],\n            [ PinchRecognizer, { enable: false },\n                [ 'rotate' ]\n            ],\n            [ SwipeRecognizer, { direction: DIRECTION_HORIZONTAL } ],\n            [ PanRecognizer, { direction: DIRECTION_HORIZONTAL },\n                [ 'swipe' ]\n            ],\n            [ TapRecognizer ],\n            [ TapRecognizer, { event: 'doubletap', taps: 2 },\n                [ 'tap' ]\n            ],\n            [ PressRecognizer ]\n        ],\n\n        /**\n         * Some CSS properties can be used to improve the working of Hammer.\n         * Add them to this method and they will be set when creating a new Manager.\n         * @namespace\n         */\n        cssProps: {\n            /**\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userSelect: 'none',\n\n            /**\n             * Disable the Windows Phone grippers when pressing an element.\n             * @type {String}\n             * @default 'none'\n             */\n            touchSelect: 'none',\n\n            /**\n             * Disables the default callout shown when you touch and hold a touch target.\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\n             * a callout containing information about the link. This property allows you to disable that callout.\n             * @type {String}\n             * @default 'none'\n             */\n            touchCallout: 'none',\n\n            /**\n             * Specifies whether zooming is enabled. Used by IE10>\n             * @type {String}\n             * @default 'none'\n             */\n            contentZooming: 'none',\n\n            /**\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n             * @type {String}\n             * @default 'none'\n             */\n            userDrag: 'none',\n\n            /**\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\n             * clickable element in iOS. This property obeys the alpha value, if specified.\n             * @type {String}\n             * @default 'rgba(0,0,0,0)'\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\n     * Manager\n     * @param {HTMLElement} element\n     * @param {Object} [options]\n     * @constructor\n     */\n    function Manager( element, options ) {\n        this.options = assign( {}, Hammer.defaults, options || {} );\n\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n        this.oldCssProps = {};\n\n        this.element = element;\n        this.input = createInputInstance( this );\n        this.touchAction = new TouchAction( this, this.options.touchAction );\n\n        toggleCssProps( this, true );\n\n        each( this.options.recognizers, function ( item ) {\n            var recognizer = this.add( new( item[ 0 ] )( item[ 1 ] ) );\n            item[ 2 ] && recognizer.recognizeWith( item[ 2 ] );\n            item[ 3 ] && recognizer.requireFailure( item[ 3 ] );\n        }, this );\n    }\n\n    Manager.prototype = {\n        /**\n         * set options\n         * @param {Object} options\n         * @returns {Manager}\n         */\n        set: function ( options ) {\n            assign( this.options, options );\n\n            // Options that need a little more setup\n            if ( options.touchAction ) {\n                this.touchAction.update();\n            }\n            if ( options.inputTarget ) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\n         * stop recognizing for this session.\n         * This session will be discarded, when a new [input]start event is fired.\n         * When forced, the recognizer cycle is stopped immediately.\n         * @param {Boolean} [force]\n         */\n        stop: function ( force ) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\n         * run the recognizers!\n         * called by the inputHandler function on every movement of the pointers (touches)\n         * it walks through all the recognizers and tries to detect the gesture that is being made\n         * @param {Object} inputData\n         */\n        recognize: function ( inputData ) {\n            var session = this.session;\n            if ( session.stopped ) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults( inputData );\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if ( !curRecognizer || ( curRecognizer && curRecognizer.state & STATE_RECOGNIZED ) ) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while ( i < recognizers.length ) {\n                recognizer = recognizers[ i ];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if ( session.stopped !== FORCED_STOP && ( // 1\n                        !curRecognizer || recognizer == curRecognizer || // 2\n                        recognizer.canRecognizeWith( curRecognizer ) ) ) { // 3\n                    recognizer.recognize( inputData );\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if ( !curRecognizer && recognizer.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED ) ) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\n         * get a recognizer by its event name.\n         * @param {Recognizer|String} recognizer\n         * @returns {Recognizer|Null}\n         */\n        get: function ( recognizer ) {\n            if ( recognizer instanceof Recognizer ) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for ( var i = 0; i < recognizers.length; i++ ) {\n                if ( recognizers[ i ].options.event == recognizer ) {\n                    return recognizers[ i ];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * add a recognizer to the manager\n         * existing recognizers with the same event name will be removed\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer|Manager}\n         */\n        add: function ( recognizer ) {\n            if ( invokeArrayArg( recognizer, 'add', this ) ) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get( recognizer.options.event );\n            if ( existing ) {\n                this.remove( existing );\n            }\n\n            this.recognizers.push( recognizer );\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\n         * remove a recognizer by name or instance\n         * @param {Recognizer|String} recognizer\n         * @returns {Manager}\n         */\n        remove: function ( recognizer ) {\n            if ( invokeArrayArg( recognizer, 'remove', this ) ) {\n                return this;\n            }\n\n            recognizer = this.get( recognizer );\n\n            // let's make sure this recognizer exists\n            if ( recognizer ) {\n                var recognizers = this.recognizers;\n                var index = inArray( recognizers, recognizer );\n\n                if ( index !== -1 ) {\n                    recognizers.splice( index, 1 );\n                    this.touchAction.update();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * bind event\n         * @param {String} events\n         * @param {Function} handler\n         * @returns {EventEmitter} this\n         */\n        on: function ( events, handler ) {\n            if ( events === undefined ) {\n                return;\n            }\n            if ( handler === undefined ) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each( splitStr( events ), function ( event ) {\n                handlers[ event ] = handlers[ event ] || [];\n                handlers[ event ].push( handler );\n            } );\n            return this;\n        },\n\n        /**\n         * unbind event, leave emit blank to remove all handlers\n         * @param {String} events\n         * @param {Function} [handler]\n         * @returns {EventEmitter} this\n         */\n        off: function ( events, handler ) {\n            if ( events === undefined ) {\n                return;\n            }\n\n            var handlers = this.handlers;\n            each( splitStr( events ), function ( event ) {\n                if ( !handler ) {\n                    delete handlers[ event ];\n                } else {\n                    handlers[ event ] && handlers[ event ].splice( inArray( handlers[ event ], handler ), 1 );\n                }\n            } );\n            return this;\n        },\n\n        /**\n         * emit event to the listeners\n         * @param {String} event\n         * @param {Object} data\n         */\n        emit: function ( event, data ) {\n            // we also want to trigger dom events\n            if ( this.options.domEvents ) {\n                triggerDomEvent( event, data );\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[ event ] && this.handlers[ event ].slice();\n            if ( !handlers || !handlers.length ) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function () {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while ( i < handlers.length ) {\n                handlers[ i ]( data );\n                i++;\n            }\n        },\n\n        /**\n         * destroy the manager and unbinds all events\n         * it doesn't unbind dom events, that is the user own responsibility\n         */\n        destroy: function () {\n            this.element && toggleCssProps( this, false );\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\n     * add/remove the css properties as defined in manager.options.cssProps\n     * @param {Manager} manager\n     * @param {Boolean} add\n     */\n    function toggleCssProps( manager, add ) {\n        var element = manager.element;\n        if ( !element.style ) {\n            return;\n        }\n        var prop;\n        each( manager.options.cssProps, function ( value, name ) {\n            prop = prefixed( element.style, name );\n            if ( add ) {\n                manager.oldCssProps[ prop ] = element.style[ prop ];\n                element.style[ prop ] = value;\n            } else {\n                element.style[ prop ] = manager.oldCssProps[ prop ] || '';\n            }\n        } );\n        if ( !add ) {\n            manager.oldCssProps = {};\n        }\n    }\n\n    /**\n     * trigger dom event\n     * @param {String} event\n     * @param {Object} data\n     */\n    function triggerDomEvent( event, data ) {\n        var gestureEvent = document.createEvent( 'Event' );\n        gestureEvent.initEvent( event, true, true );\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent( gestureEvent );\n    }\n\n    assign( Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        assign: assign,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    } );\n\n    // this prevents errors when Hammer is loaded in the presence of an AMD\n    //  style loader but by script tag, not by the loader.\n    var freeGlobal = ( typeof window !== 'undefined' ? window : ( typeof self !== 'undefined' ? self : {} ) ); // jshint ignore:line\n    freeGlobal.Hammer = Hammer;\n\n    if ( typeof define === 'function' && define.amd ) {\n        define( function () {\n            return Hammer;\n        } );\n    } else if ( typeof module != 'undefined' && module.exports ) {\n        module.exports = Hammer;\n    } else {\n        window[ exportName ] = Hammer;\n    }\n\n} )( window, document, 'Hammer' );\n\n\nmodule.exports = Hammer;\n\n\nmodule.exports._ = _;\n})"]}