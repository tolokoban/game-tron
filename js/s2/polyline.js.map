{"version":3,"sources":["polyline.js"],"names":["require","module","exports","_","readonly","DIM2","IDX_X0","IDX_Y0","IDX_X1","IDX_Y1","DEFAULT_CAPACITY","Polyline","x","y","capacity","arr","Float32Array","_arr","_start","_length","_capacity","length","firstX","firstY","lastX","lastY","callback","k","index","dx","dy","nextIdx","startIdx","x0","y0","x1","y1","collideVertical","call","collideHorizontal","_y0","_y1","idx","offset","Math","min","max","idx0","xx0","yy","idx1","xx1","xMin","xMax","_x0","_x1","yy0","xx","yy1","yMin","yMax"],"mappings":"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","sourcesContent":["/** @module s2/polyline */require( 's2/polyline', function(require, module, exports) { var _=function(){return ''};   \"use strict\";\r\n\r\nconst { readonly } = require(\"common\");\r\n\r\nconst DIM2 = 2,\r\n      IDX_X0 = 0,\r\n      IDX_Y0 = 1,\r\n      IDX_X1 = 2,\r\n      IDX_Y1 = 3,\r\n      DEFAULT_CAPACITY = 128;\r\n\r\n\r\nclass Polyline {\r\n\r\n    /**\r\n     * @param {float} x - Abscisse du premier point.\r\n     * @param {float} y - Ordonnée du premier point.\r\n     * @param {int} capacity - Nombre maximal de points.\r\n     */\r\n    constructor(x, y, capacity = DEFAULT_CAPACITY) {\r\n        // On multiplie la capacité par 2 car il y a deux éléments par point (x et y).\r\n        const arr = new Float32Array( capacity << 1 );\r\n        arr[IDX_X0] = x;\r\n        arr[IDX_Y0] = y;\r\n        arr[IDX_X1] = x;\r\n        arr[IDX_Y1] = y;\r\n        this._arr = arr;\r\n        this._start = 0;\r\n        this._length = DIM2 << 1;\r\n        this._capacity = capacity << 1;\r\n\r\n\r\n        readonly( this, {\r\n            length() {\r\n                // Diviser par deux.\r\n                return this._length >> 1;\r\n            },\r\n\r\n            firstX() {\r\n                return this._arr[this._start];\r\n            },\r\n\r\n            firstY() {\r\n                return this._arr[this._start + 1];\r\n            },\r\n\r\n            lastX() {\r\n                return this._arr[(this._start + this._length - DIM2) % this._capacity];\r\n            },\r\n\r\n            lastY() {\r\n                return this._arr[(this._start + this._length - DIM2 + 1) % this._capacity];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {function} callback - Fonction appelée pour chaque point de la fin d'un segment.\r\n     * Les argument passés sont `(x, y)`.\r\n     */\r\n    foreachTail(callback) {\r\n        const arr = this._arr;\r\n        for( let k = DIM2; k < this._length; k += DIM2 ) {\r\n            const index = (k + this._start) % this._length;\r\n            callback( arr[index], arr[index + 1] );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Déplace le point libre du dernier pan de mur.\r\n     * @param {float} dx - Valeur à ajouter à l'abscisse.\r\n     * @param {float} dy - Valeur à ajouter à l'ordonnée.\r\n     */\r\n    move(dx, dy) {\r\n        const index = (this._start + this._length - DIM2) % this._capacity;\r\n        this._arr[index] += dx;\r\n        this._arr[index + 1] += dy;\r\n    }\r\n\r\n    /**\r\n     * Ajoute un nouveau segment de mur.\r\n     * Pour commencer, il aura une taille nulle.\r\n     */\r\n    add() {\r\n        const index = (this._start + this._length - DIM2) % this._capacity,\r\n              arr = this._arr,\r\n              x = arr[index],\r\n              y = arr[index + 1];\r\n        if( this._length < this._capacity ) {\r\n            const nextIdx = (index + DIM2) % this._capacity;\r\n            arr[nextIdx] = x;\r\n            arr[nextIdx + 1] = y;\r\n            this._length += DIM2;\r\n        } else {\r\n            // Le buffer est plein, on écrase le plus ancien point.\r\n            const startIdx = this._start;\r\n            arr[startIdx] = x;\r\n            arr[startIdx + 1] = y;\r\n            this._start = (this._start + DIM2) % this._capacity;\r\n        }\r\n    }\r\n\r\n    collide( x0, y0, x1, y1 ) {\r\n        if( x0 === x1 ) return collideVertical.call( this, x0, y0, y1 );\r\n        return collideHorizontal.call( this, y0, x0, x1 );\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = Polyline;\r\n\r\n\r\n/**\r\n * On recherche une collision entre un segment vertical et au moins un des murs horizonzaux.\r\n * @this Polyline\r\n */\r\nfunction collideVertical( x, _y0, _y1 ) {    \r\n    if( _y0 === _y1 ) {\r\n        // L'objet qui veut tester la collision est immobile.\r\n        return false;\r\n    }\r\n    \r\n    const arr = this._arr,\r\n          idx = (this._start + DIM2) % this._capacity,\r\n          offset = this.firstX === arr[idx] ? DIM2 : 0,\r\n          y0 = Math.min( _y0, _y1 ),\r\n          y1 = Math.max( _y0, _y1 );\r\n\r\n    for( let k = offset; k < this._length; k += DIM2 + DIM2 ) {\r\n        // On ne teste que les segments horizonzaux de murs.\r\n        const idx0 = (k + this._start) % this._length,\r\n              xx0 = arr[idx0],\r\n              // Inutile de lire Y  pour les deux extrémités du segment : ce  sont les mêmes pour un\r\n              // segment horizontal.\r\n              yy = arr[idx0 + 1],\r\n              idx1 = (idx0 + DIM2) % this._length,\r\n              xx1 = arr[idx1];        \r\n        if( xx0 === xx1 ) {\r\n            // Ce mur est réduit à un point. On peut donc arrêter les tests.\r\n            break;\r\n        }\r\n        const xMin = Math.min( xx0, xx1 ),\r\n              xMax = Math.max( xx0, xx1 );\r\n        if( ( x <= xMin ) || ( x >= xMax ) ) continue;\r\n        if( ( yy < y0 ) || ( yy > y1 ) ) continue;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nfunction collideHorizontal( y, _x0, _x1 ) {\r\n    if( _x0 === _x1 ) {\r\n        // L'objet qui veut tester la collision est immobile.\r\n        return false;\r\n    }\r\n    \r\n    const arr = this._arr,\r\n          idx = (this._start + DIM2 + 1) % this._capacity,\r\n          offset = this.firstY === arr[idx] ? DIM2 : 0,\r\n          x0 = Math.min( _x0, _x1 ),\r\n          x1 = Math.max( _x0, _x1 );\r\n\r\n    for( let k = offset; k < this._length; k += DIM2 + DIM2 ) {\r\n        // On ne teste que les segments horizonzaux de murs.\r\n        const idx0 = (k + this._start) % this._length,\r\n              yy0 = arr[idx0 + 1],\r\n              // Inutile de lire X  pour les deux extrémités du segment : ce  sont les mêmes pour un\r\n              // segment vertical.\r\n              xx = arr[idx0],\r\n              idx1 = (idx0 + DIM2) % this._length,\r\n              yy1 = arr[idx1 + 1];        \r\n        if( yy0 === yy1 ) {\r\n            // Ce mur est réduit à un point. On peut donc arrêter les tests.\r\n            break;\r\n        }\r\n        const yMin = Math.min( yy0, yy1 ),\r\n              yMax = Math.max( yy0, yy1 );\r\n        if( ( y <= yMin ) || ( y >= yMax ) ) continue;\r\n        if( ( xx < x0 ) || ( xx > x1 ) ) continue;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n\r\nmodule.exports._ = _;\n})"]}